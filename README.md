Hoodie
======

This is an experimental fun project that implements *weighted* nearest neighbour search using euclidian distance.
NNS is implemented using in-memory index structures. The goal is to come up with something that might be suitable for
graph databases.

Hoodie stores an arbitrary set of records where each record is a multidimensional value. The list of fields
of each record is described statically by creating a "schema" using the chosen implementation's schema
factory.

Example.

      val builder = schemaFactory.newBuilder
      builder.addField[Int]("age")
      builder.addField[Boolean]("bald")
      builder.addField[Float]("size")
      val schema = builder.result

The resulting schema instance provides insert and search calls for nearest neighbour search.


Supported field types
---------------------

Currently the only supported field types are Int, Boolean, Float.

Schema data may be parsed from csv string by using schema.mkFromString (expects the use of ',' as separator and
 java literal syntax, i.e '12, true, 4.5')

Adding more field types is possible, you need to define an "IXS" (print and parse), a "WDM" (weighted distance
measure comparator) and modify the implementations.  In encore, edit "PrimRecord" and search for "mf match" to find the
relevant places in the code.


Status
------

Works but is still too slow

For 2125764 records (7 float dimensions, using random values), I get 1.8 secs on average to find top-3 elements on
a 2.3 GHz laptop

For EncoreSearch5 (20 dims, 100000 recs each) I get:

Memory (bytes) used until creation: 87316624 per record: 873 and dimension: 43
Time per search (ms): 465
Memory (bytes) used until end of search: 90287784 per record: 902 and dimension: 45

To try it out, see the code in src/test/scala/instantiates.scala


Plans
-----

So, this thing uses way too much memory and doesn't give that fast query time for it

Best way to proceed is to replace the skip lists with binary search based arrays, that should cut
memory consumption drastically. Needed along: Rewrite of iterators, ideally they are more array like
and the iters pq only stores Ints.


Encore Implementation
=====================

This currently is the only provided implementation. Encore uses records that aggregate all field values
by type into arrays in order to be space efficient (and avoid boxing of property maps). For each field, a
skip-list based index is kept. All records are inserted into all indices. The skip-list forward pointers
are also stored directly in the records.  This record structure is space efficient but the skip-list
pointers go all over the place and are thus not too cache friendly (The skip-list implementation is a straightforward
adaptation of the algorithms from W. Pughs "A Skip-List Cookbook" to PrimRecords including the "alreadyChecked"
optimization).


Nearest neighbour search is performed as outlined below:

0. Create iterators for all skip list dimensions that output the nearest point that can be found when moving in
   that dimension in increasing order of distance (Distance here only refers to the weighted distance in that dimension,
   i.e. iterators produce elements in monotonically increasing weighted, dimensional (single field) distance)

   Create a priority queue for candidates sorted according to the euclidian (all fields), weighted distance.

1. Scan all iterators and add their top-element to the candidate queue

   While adding, keep track of the maximum dimension distance per dimension generated by the associated iterator
   (bound values)

2. Use the bound values to compute a "cut value". The cut value is the minimum distance of any value that will
   be produced by future iteration.

3. Scan the candidate queue for all values closer to the query point than the cut distance and deliver them as results.

4. Continue at 1 until enough results have been found or all iterators have been exhausted.


Why does this work?
-------------------

Completeness: Every iterator essentially is a permutation of all record fields so every record eventually will be added
to the pq.


Correctness: Sorting order in general is ensured by the pq. The only way in which a relevant record might be missed
would be due to the cut criterion. For brevity, assume two dimensions, x and y and assume the query point is at the
origin (0,0).

Let the pq contain

r1: (x1, y1) with distance d1
r2: (x2, y2) with distance d2

with max values x1 > x2 and y2 > y1 and thus the cut c=sqrt(x1*x1 + y2*y2) and assume c > d1 and c > d2 and thus both
 records r1, r2 get delivered as results.

Now, the claim is that any record from the iterators is either farther away than the cut or has been seen already.
Without loss of generality, fix the iterator to be the one from the x dimension.

Let the record be r3: (x3, y3) with distance d3 = sqrt(x3*x3, y3*y3)

If d3 > c everything is nice. So assume d3 < c.

We know x3 >= x2 due to the value of c. Without loss of generality set x3 = x2:

We have

d3 < c
sqrt(x3*x3 + y3*y3) < sqrt(x2*x2 + y2*y2)
sqrt(x2*x2 + y3*y3) < sqrt(x2*x2 + y2*y2)

For d3 < c we need, y3*y3 < y2*y2.  However, in that case r3 would have been generated by the y iterator before and
been added to the pq in time.

Next, let's generalize this for more dimensions:

Let r3: (x3, y3, z3, t3, v3) be from the x iterator. d3 < c = sqrt(xm*xm + ... + vm*vm). For simplicity, set
x3=xm.

d3 < c
sqrt(xm*xm + y3*y3 + ... + v3*v3) < sqrt(xm*xm + ym*ym + ... + vm*vm)

If any of y3, .., v3 is smaller than ym, ..., vm, r3 would have been delivered by any of the other iterators before.

Thus y3 >= ym, ..., v3 >= vm.  From this it follows that d3 >= c3. Contradiction. Qed.

Weights: The skip list indices sort records unweighted. However, since we only allow linear, positive weights this
 is no problem and the order of values generated by the iterators is not affected.  Secondly, the use of
 positive, linear weights for cut and priority queue does not affect above argument.




TODO
----

- [X] Verify dimSize
- [X] Make it work (search still has a bug the order is only "mostly correct")
- [-] Search from non-inserted point (broken, searchApprox needs fix, for now, insert to search)
- [ ] Little http server for accessing
- [ ] Delete
- [ ] Batching of updates
- [X]ÊGetter for number of elements























